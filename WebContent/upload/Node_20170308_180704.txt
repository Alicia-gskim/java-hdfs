양방향 서버 통신 : socket.io (push 방식과 같음)
node.js 는 event loop 방식(싱글 스레드 모델)
비동기 소켓 체크(node.js는 os를 탄다)

WAS 스레드(톰캠) : 동시 처리 가능한 트렌젝션 양이 쓰레드 수 만큼 밖에 안된다(ex:100개면 100개만 처리 가능) , 많은 스레드를 받는데 한계가 있다.
non blocking i/o

socket.io를 활용해서 클러스터링도 가능하다.(잛은 소스 구현으로)
angular.js를 사용해서 간단한 single page app을 구현할 수 있다.
npm : maven + rpm
package.json = maven -> pom.xml과 같은 역활을 해준다.
express : 웹 어플리케이션 개발 프레임워크

*이벤트 보내고 받기
브라우저 버전에 따라서 socket.io가 자동으로 방식을 정해서 서버에 이벤트를 보내준다.
이벤트 보내기 : socket.emit("이벤트명", {메세지});
이벤트 받기 : socket.on("이벤트명", function(data){});
나를 제외한 클라이언트들에게 이벤트 보내기 : socket.broadcast.emit("이벤트명", {메세지});
나를 포함한 모든 클라이언트들에게 이벤트 보내기 : io.socket.emit("이벤트명", function(data){});
다른 특정 소켓에 메세지 보내기 : io.socket(소켓ID).emit("이벤트명",{메세지});

*소켓에 데이터 바인딩
저장 : socket.set("키", "값", function(){});
가져오기 : socket.get("키", "값", function(err, value){});
지우기 : socket.del("키", function(err, value){});
*현재 소켓의 ID가져오기
socket.id

*Room(채널)
채널 조인하기 : socket.join("룸이름");
채널에서 나오기 : socket.leave("룸이름");
룸안에 있는 소켓에 이벤트 보내기 : io.sockets.in("룸이름").emit("이벤트", {메세지});
룸안에 있는 나를 제외한 소켓에 메세지 보내기 : socket.broadcast.to("룸이름").emit("이벤트",{메세지});
현재 생성되어 있는 룸 이름 읽어오기 : io.sockets.manager.rooms
룸안에 있는 소켓 목록 리턴 : io.sockets.client("룸이름");

!!!비동기 코딩 패턴!!!
node.js는 순차적인 실행이 안된다.


단위 테스트 = Mocha test framework
TDD = Test Driven Developer : 테스트 케이스를 만들고 테스트 케이스를 제거해 나가는 방식으로 개발해 나가는 컨셉
코드가 있다는 가정하에 만들어 나가는 방식
BDD = Buiseness Driven Developer

passport
winstone